generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id         String   @id @default(cuid())
  supabaseId String   @unique
  name       String
  email      String   @unique
  avatar     String?
  plan       PlanType @default(FREE)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  hostedSpaces      Space[]            @relation("HostedSpaces")
  spaceParticipants SpaceParticipant[]
}

enum PlanType {
  FREE
  PRO
  BUSINESS
}

model Space {
  id                  String          @id @default(cuid())
  hostId              String
  host                User            @relation("HostedSpaces", fields: [hostId], references: [id])
  title               String
  description         String?
  joinCode            String          @unique
  status              SpaceStatus     @default(LIVE)
  recordingStatus     RecordingStatus @default(IDLE)
  startTime           DateTime?
  endTime             DateTime?
  duration            Int? // milliseconds
  totalRecordingHours Float?
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt

  participants      SpaceParticipant[]
  recordingSessions RecordingSession[]
  finalOutputs      FinalOutput[]
}

enum SpaceStatus {
  LIVE // meeting active, users connected
  ENDED // host ended meeting
  PROCESSING // backend merging recordings
  READY // meeting + final output ready
}

enum RecordingStatus {
  IDLE // recording not started
  RECORDING // recording active
  STOPPED // recording stopped
}

model SpaceParticipant {
  id                   String          @id @default(cuid())
  spaceId              String
  space                Space           @relation(fields: [spaceId], references: [id])
  userId               String?
  user                 User?           @relation(fields: [userId], references: [id])
  participantSessionId String
  displayName          String?
  isGuest              Boolean         @default(false)
  isActive             Boolean         @default(true)
  role                 ParticipantRole @default(GUEST)
  joinedAt             DateTime        @default(now())
  leftAt               DateTime?
  hasRecording         Boolean         @default(false)

  recordings ParticipantRecording[]

  @@index([spaceId])
  @@index([userId])
  @@index([participantSessionId])
  @@index([spaceId, isActive])
}

enum ParticipantRole {
  HOST
  CO_HOST
  GUEST
}

model RecordingSession {
  id                 String                 @id @default(cuid())
  spaceId            String
  space              Space                  @relation(fields: [spaceId], references: [id])
  recordingSessionId String                 @unique
  startedAt          DateTime               @default(now())
  stoppedAt          DateTime?
  status             RecordingSessionStatus @default(ACTIVE)
  createdAt          DateTime               @default(now())

  participantRecordings ParticipantRecording[]
  finalOutputs          FinalOutput[]
}

enum RecordingSessionStatus {
  ACTIVE
  STOPPED
  PROCESSING
  READY
  FAILED
}

model ParticipantRecording {
  id                 String           @id @default(cuid())
  recordingSessionId String
  recordingSession   RecordingSession @relation(fields: [recordingSessionId], references: [id])
  participantId      String
  participant        SpaceParticipant @relation(fields: [participantId], references: [id])

  type          RecordingType
  isScreenShare Boolean       @default(false)

  //metadata
  container  String?
  codec      String?
  width      Int?
  height     Int?
  fps        Int?
  bitrate    Int?
  sampleRate Int?
  channels   Int?
  hasAudio   Boolean @default(false)
  hasVideo   Boolean @default(false)

  //quality (for UI)
  videoQuality VideoQuality?
  audioQuality AudioQuality?
  videoLabel   String? // "1080p • 30fps • 4.8 Mbps"
  audioLabel   String? // "48 kHz • Stereo • 192 kbps"

  // timeline & processing state
  startOffsetMs   Int?
  durationMs      Int?
  lastChunkAt     DateTime?
  fileKey         String? // S3 key for uploaded chunk
  fileSize        BigInt?
  checksum        String? // sha256 checksum of the uploaded chunk
  mimeType        String?
  status          RecordingFileStatus @default(UPLOADING)
  processingJobId String?
  processingError String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  segments     RecordingSegment[]
  finalOutputs FinalOutput[]

  @@index([recordingSessionId])
  @@index([participantId])
  @@index([status])
}

enum RecordingType {
  AUDIO
  VIDEO
}

enum RecordingFileStatus {
  UPLOADING
  UPLOADED
  PROCESSING
  READY
  FAILED
}

model RecordingSegment {
  id                     String               @id @default(cuid())
  participantRecordingId String
  participantRecording   ParticipantRecording @relation(fields: [participantRecordingId], references: [id])

  recordingSessionId String
  spaceId            String
  participantId      String

  assetKey   String // S3 key for uploaded chunk
  startMs    Int // offset from session start in milliseconds
  durationMs Int // duration in milliseconds
  sizeBytes  BigInt
  checksum   String? // optional sha256
  uploadedAt DateTime      @default(now())
  status     SegmentStatus @default(UPLOADED)

  @@index([participantRecordingId])
  @@index([participantRecordingId, startMs])
  @@index([recordingSessionId])
  @@index([participantId])
  @@index([status])
}

enum SegmentStatus {
  UPLOADED
  PROCESSING
  PROCESSED
  FAILED
}

/// Final output (logical exported file: composite or per-participant)
model FinalOutput {
  id                 String           @id @default(cuid())
  recordingSessionId String
  recordingSession   RecordingSession @relation(fields: [recordingSessionId], references: [id])
  spaceId            String
  space              Space            @relation(fields: [spaceId], references: [id])

  // WHAT this output is and WHAT it contains
  type FinalOutputType
  mode FinalOutputMode @default(MIXED) // MIXED = video+audio, VIDEO_ONLY, AUDIO_ONLY

  // WHO/WHERE it came from (nullable)
  targetParticipantId String? // SpaceParticipant.id when type = PER_PARTICIPANT
  sourceRecordingId   String? // ParticipantRecording.id if derived from a single participant master
  sourceRecording     ParticipantRecording? @relation(fields: [sourceRecordingId], references: [id])

  // master metadata (actual properties of the produced master file)
  width      Int?
  height     Int?
  fps        Int?
  bitrate    Int?
  sampleRate Int?
  channels   Int?
  hasAudio   Boolean? // true if master contains audio
  hasVideo   Boolean? // true if master contains video

  // derived convenience fields (set by worker when master ready)
  videoQuality VideoQuality? // enum (P360..P2160)
  audioQuality AudioQuality? // enum (SR_22050..SR_96000)
  videoLabel   String? // "1080p • 30fps • 4.8 Mbps"
  audioLabel   String? // "48 kHz • Stereo • 192 kbps"

  //preview image
  thumbnailKey String? // s3 key for a thumbnail image

  // result (master final file)
  masterKey       String? // S3 key of result (composite or single)
  mimeType        String?
  durationMs      Int?
  fileSize        BigInt?
  checksum        String?
  status          OutputStatus @default(QUEUED)
  processingJobId String?
  errorMessage    String?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  renditions FinalOutputRendition[]

  @@index([recordingSessionId])
  @@index([spaceId])
  @@index([status])
  @@index([targetParticipantId])
}

enum FinalOutputType {
  COMPOSITE
  PER_PARTICIPANT
}

enum FinalOutputMode {
  MIXED // video + audio
  VIDEO_ONLY
  AUDIO_ONLY
}

enum OutputStatus {
  QUEUED
  PROCESSING
  READY
  FAILED
}

/// Cached / generated renditions (different resolutions / bitrates)
model FinalOutputRendition {
  id            String      @id @default(cuid())
  finalOutputId String
  finalOutput   FinalOutput @relation(fields: [finalOutputId], references: [id])

  // rendition properties
  width     Int?
  height    Int?
  bitrate   Int? // bits per second
  codec     String?
  container String?
  assetKey  String? // s3 key for this rendition
  sizeBytes BigInt?
  status    RenditionStatus @default(GENERATING)
  jobId     String? // worker job id
  createdAt DateTime        @default(now())

  @@unique([finalOutputId, width, height])
  @@index([finalOutputId, width, height])
  @@index([assetKey])
}

enum RenditionStatus {
  READY
  GENERATING
  FAILED
}

enum VideoQuality {
  P360
  P480
  P720
  P1080
  P1440
  P2160 // 4K
}

enum AudioQuality {
  SR_22050
  SR_44100
  SR_48000
  SR_96000
}
