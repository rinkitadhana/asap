generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id         String   @id @default(cuid())
  supabaseId String   @unique
  name       String
  email      String   @unique
  avatar     String?
  plan       PlanType @default(FREE)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  spacesCreated     Space[]            @relation("HostSpaces")
  spaceParticipants SpaceParticipant[]
  planUsages        PlanUsage[]
}

enum PlanType {
  FREE
  PRO
  BUSINESS
}

model Space {
  id                  String          @id @default(cuid())
  hostId              String
  host                User            @relation("HostSpaces", fields: [hostId], references: [id])
  title               String
  description         String?
  joinCode            String          @unique
  status              SpaceStatus     @default(LIVE)
  recordingStatus     RecordingStatus @default(IDLE)
  startTime           DateTime?
  endTime             DateTime?
  duration            Int? // seconds
  planUsed            PlanType        @default(FREE)
  totalRecordingHours Float?
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt

  participants    SpaceParticipant[]
  recordings      Recording[]
  finalRecordings FinalRecording[]
}

enum SpaceStatus {
  LIVE // meeting active, users connected
  ENDED // host ended meeting
  PROCESSING // backend merging recordings
  READY // meeting + final output ready
}

enum RecordingStatus {
  IDLE // recording not started
  RECORDING // recording active
  STOPPED // recording stopped
}

model SpaceParticipant {
  id           String          @id @default(cuid())
  spaceId      String
  space        Space           @relation(fields: [spaceId], references: [id])
  userId       String
  user         User            @relation(fields: [userId], references: [id])
  role         ParticipantRole
  joinedAt     DateTime        @default(now())
  leftAt       DateTime?
  hasRecording Boolean         @default(false)
  recordings   Recording[]

  @@unique([userId, spaceId])
  @@index([spaceId])
  @@index([userId])
}

enum ParticipantRole {
  HOST
  CO_HOST
  GUEST
}

model Recording {
  id            String              @id @default(cuid())
  spaceId       String
  space         Space               @relation(fields: [spaceId], references: [id])
  participantId String
  participant   SpaceParticipant    @relation(fields: [participantId], references: [id])

  type           RecordingType
  videoQuality   VideoQuality?       // only for VIDEO type
  audioQuality   AudioQuality?       // only for AUDIO type
  uploadedChunks Json                // array of uploaded chunk URLs [{url, timestamp, size}]
  fileUrl        String?             // final merged file URL for this specific track
  fileSize       BigInt?             // file size in bytes
  status         RecordingFileStatus @default(UPLOADING)
  startedAt      DateTime
  endedAt        DateTime?
  duration       Int?                // seconds
  localUpload    Boolean             @default(true)
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt

  @@index([spaceId])
  @@index([participantId])
  @@index([type])
}

enum RecordingType {
  AUDIO
  VIDEO
}

enum RecordingFileStatus {
  UPLOADING     // chunks being uploaded
  UPLOADED      // all chunks uploaded
  PROCESSING    // backend processing/merging chunks
  READY         // final file ready
  FAILED        // processing failed
}

enum VideoQuality {
  P720          // 1280x720
  P1080         // 1920x1080
  P1440         // 2560x1440
  P4K           // 3840x2160
}

enum AudioQuality {
  SR_44100      // 44.1 kHz (CD quality)
  SR_48000      // 48 kHz (professional standard)
  SR_96000      // 96 kHz (high-res audio)
}

model FinalRecording {
  id                 String         @id @default(cuid())
  spaceId            String         @unique
  space              Space          @relation(fields: [spaceId], references: [id])
  status             OutputStatus   @default(PROCESSING)
  
  // Primary output - single video file with audio mixed in (ready to use/download)
  finalVideo         String?        // complete video with all participants + audio combined
  videoQuality       VideoQuality   @default(P1080)
  audioQuality       AudioQuality   @default(SR_48000)
  duration           Int?           // seconds
  fileSize           BigInt?        // file size in bytes
  
  // Optional: Audio-only export (for users who want just audio)
  finalAudio         String?        // extracted audio track from final video
  
  // Individual participant tracks for separate downloads
  // Structure: { participantId: { video: {P720: "recordingId", P1080: "recordingId"}, audio: {SR_48000: "recordingId"} } }
  // Frontend can fetch Recording entries using these IDs to get download URLs
  separateTracks     Json?          // maps to Recording IDs per participant
  
  processingStarted  DateTime?
  processingEnded    DateTime?
  errorMessage       String?        // if status is FAILED
  
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt

  @@index([spaceId])
  @@index([status])
}

enum OutputStatus {
  QUEUED           // waiting to start processing
  PROCESSING       // actively merging recordings
  READY            // final output available
  FAILED           // processing failed
}

model PlanUsage {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  
  month     String // e.g. "2025-11"
  hoursUsed Float    @default(0)
  hoursCap  Float
  createdAt DateTime @default(now())

  @@unique([userId, month])
  @@index([userId])
}
